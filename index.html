<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>RPG V13: Perfection</title>
    <style>
        /* CSS Styles */
        body { margin: 0; overflow: hidden; background: #050505; color: #ccc; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; cursor: crosshair; }

        /* UI Base */
        .ui-win { position: absolute; background: rgba(10, 12, 14, 0.95); border: 1px solid #444; border-radius: 2px; padding: 8px; box-shadow: 0 0 15px #000; pointer-events: auto; transition: height 0.3s; overflow: hidden; }
        .ui-head { background: linear-gradient(90deg, #1a1a1a, #2a2a2a); color: #dcb; padding: 6px; text-align: center; font-weight: bold; border-bottom: 1px solid #444; margin: -8px -8px 8px -8px; font-size: 13px; display: flex; justify-content: space-between; align-items: center; letter-spacing: 1px; }
        
        button { background: #222; border: 1px solid #555; color: #bbb; padding: 5px 12px; cursor: pointer; font-size: 11px; transition: 0.2s; font-family: 'Segoe UI', sans-serif; }
        button:hover { background: #444; color: #fff; border-color: #888; }
        button:active { background: #111; }
        .btn-mini { padding: 2px 6px; font-size: 10px; }
        .btn-close { background: #522; border-color: #744; }
        .btn-close:hover { background: #722; }

        /* System Buttons */
        #sys-btns { position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; z-index: 1000; }

        /* HUD */
        #hud { top: 10px; left: 10px; width: 260px; }
        .bar-wrap { background: #111; height: 12px; border: 1px solid #333; margin-bottom: 4px; position: relative; }
        .bar-fill { height: 100%; transition: width 0.1s linear; }
        .bar-txt { position: absolute; top: -1px; left: 0; width: 100%; text-align: center; font-size: 10px; line-height: 12px; color: #fff; text-shadow: 1px 1px 0 #000; }
        
        /* Skill Bar */
        #skill-bar { bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 5px; }
        .skill-slot { width: 50px; height: 50px; background: #151515; border: 2px solid #444; position: relative; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; color: #888; flex-direction: column; }
        .skill-cd { position: absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); display:flex; align-items:center; justify-content:center; color:#f55; font-size:18px; font-weight:bold; display:none; border: 1px solid #800; }
        .key-hint { position: absolute; top:2px; left:3px; font-size: 10px; color: #666; font-family: monospace; }
        .pot-count { position: absolute; bottom: 2px; right: 4px; font-size: 12px; color: #fff; font-weight: bold; text-shadow: 1px 1px 0 #000; }

        /* Right Panel */
        #panel { top: 50px; right: 10px; width: 280px; max-height: 85vh; display: flex; flex-direction: column; }
        #panel-content { transition: opacity 0.2s; }
        #inv-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 3px; max-height: 250px; overflow-y: auto; background: #080808; padding: 3px; border: 1px inset #333; }
        .slot { width: 40px; height: 40px; background: #151515; border: 1px solid #333; position: relative; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 9px; text-align: center; color: #777; }
        .slot:hover { border-color: #aaa; background: #252525; color: #fff; }

        /* Rarity Effects */
        .r-0 { border-color: #555; color: #aaa; }
        .r-1 { border-color: #282; color: #4f4; }
        .r-2 { border-color: #248; color: #4af; }
        .r-3 { border-color: #628; color: #d4f; }
        .r-4 { border-color: #a60; color: #fa0; box-shadow: inset 0 0 5px #a60; }
        .r-5 { border-color: #900; color: #f22; animation: pulse 1.5s infinite; }
        .r-6 { border-color: #0ff; color: #0ff; box-shadow: 0 0 10px #0ff; animation: glow 1s infinite alternate; }
        
        /* Modals */
        .modal { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 420px; display: none; z-index: 100; }
        
        /* Chat */
        #chat { bottom: 10px; left: 10px; width: 350px; height: 200px; background: rgba(0,0,0,0.5); pointer-events: none; overflow: hidden; display: flex; flex-direction: column; justify-content: flex-end; }
        .msg { font-size: 12px; text-shadow: 1px 1px 0 #000; padding: 2px 4px; }
        .c-sys { color: #888; } .c-get { color: #6f6; } .c-dmg { color: #f66; } .c-rare { color: #fa0; font-weight: bold; }

        /* Boss Bar */
        #boss-ui { position: absolute; top: 80px; left: 50%; transform: translateX(-50%); width: 600px; display: none; pointer-events: none; }
        #boss-hp { width: 100%; height: 20px; background: #200; border: 1px solid #600; position: relative; }
        #boss-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #a00, #f22); transition: width 0.1s; }
        #boss-name { text-align:center; color:#fff; font-weight:bold; text-shadow:2px 2px 0 #000; margin-bottom:3px; font-size: 14px; letter-spacing: 2px; }

        @keyframes pulse { 0% { border-color: #f00; } 50% { border-color: #800; } 100% { border-color: #f00; } }
        @keyframes glow { from { box-shadow: 0 0 5px #0ff; } to { box-shadow: 0 0 15px #0ff; } }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="sys-btns">
        <button onclick="game.save(true)">저장</button>
        <button onclick="game.reset()">초기화</button>
    </div>

    <div id="boss-ui">
        <div id="boss-name">BOSS NAME</div>
        <div id="boss-hp"><div id="boss-fill"></div></div>
    </div>

    <!-- HUD -->
    <div id="hud" class="ui-win">
        <div class="ui-head"><span>STATUS</span></div>
        <div style="font-size:12px; margin-bottom:8px; text-align:center;">
            <span id="u-name" style="color:#fff; font-weight:bold;">Player</span> <span style="color:#aaa">Lv.</span><span id="u-lv" style="color:#fa0">1</span> <span style="color:#888" id="u-job">Warrior</span>
        </div>
        <div class="bar-wrap" style="border-color:#522"><div id="hp-bar" class="bar-fill" style="background:#b33; width:100%"></div><div class="bar-txt">HP</div></div>
        <div class="bar-wrap" style="border-color:#225"><div id="mp-bar" class="bar-fill" style="background:#33b; width:100%"></div><div class="bar-txt">MP</div></div>
        <div class="bar-wrap" style="border-color:#552"><div id="exp-bar" class="bar-fill" style="background:#bba; width:0%"></div><div class="bar-txt">EXP</div></div>
        <div style="font-size:11px; display:flex; justify-content:space-between; margin-top:6px; color:#aaa;">
            <span>GOLD: <span id="u-gold" style="color:#fd0">0</span></span>
            <span id="u-zone">Unknown Area</span>
        </div>
    </div>

    <!-- Skill Bar -->
    <div id="skill-bar">
        <div class="skill-slot" id="slot-q"><span class="key-hint">Q</span><span class="icon">Skill 1</span><div class="skill-cd" id="cd-q"></div></div>
        <div class="skill-slot" id="slot-w"><span class="key-hint">W</span><span class="icon">Skill 2</span><div class="skill-cd" id="cd-w"></div></div>
        <div class="skill-slot" id="slot-e"><span class="key-hint">E</span><span class="icon">Skill 3</span><div class="skill-cd" id="cd-e"></div></div>
        <div class="skill-slot" style="border-color:#633"><span class="key-hint">P</span>POTION<span class="pot-count" id="u-pot">0</span></div>
    </div>

    <!-- Right Panel -->
    <div id="panel" class="ui-win">
        <div class="ui-head">
            <span>CHARACTER</span>
            <button class="btn-mini" onclick="game.ui.togglePanel()">▼</button>
        </div>
        <div id="panel-content">
            <div style="font-size:11px; margin: 10px 0; color:#ccc;">
                <div style="display:flex; justify-content:space-between;"><span>공격력</span> <span id="st-atk" style="color:#fff">0</span></div>
                <div style="display:flex; justify-content:space-between;"><span>방어력</span> <span id="st-def" style="color:#fff">0</span></div>
                <div style="margin-top:5px; text-align:right;">포인트: <span id="st-pt" style="color:#f55">0</span></div>
            </div>
            <div style="display:flex; gap:4px; margin-bottom:10px;">
                <button style="flex:1" onclick="game.player.upStat('str')">힘</button>
                <button style="flex:1" onclick="game.player.upStat('dex')">민첩</button>
                <button style="flex:1" onclick="game.player.upStat('con')">체력</button>
            </div>
            <div style="border-top:1px solid #333; padding-top:10px; margin-bottom:10px;">
                <div style="font-size:11px; color:#666; margin-bottom:4px;">EQUIPMENT</div>
                <div style="display:flex; gap:5px;">
                    <div id="eq-w" class="slot">WPN</div>
                    <div id="eq-a" class="slot">AMR</div>
                </div>
            </div>
            <div class="ui-head" style="font-size:11px; margin-bottom:5px;">INVENTORY (<span id="inv-cnt">0</span>)</div>
            <div id="inv-grid"></div>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:4px; margin-top:10px;">
                <button onclick="game.ui.toggleShop()">상점</button>
                <button onclick="game.ui.toggleSmith()">대장간</button>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="shop-modal" class="ui-win modal">
        <div class="ui-head">SHOP <button class="btn-close btn-mini" onclick="game.ui.closeModals()">X</button></div>
        <div id="shop-list" style="max-height:300px; overflow-y:auto; padding:5px;"></div>
    </div>
    
    <div id="smith-modal" class="ui-win modal">
        <div class="ui-head">BLACKSMITH <button class="btn-close btn-mini" onclick="game.ui.closeModals()">X</button></div>
        <div style="padding:15px; text-align:center;">
            <div style="border-bottom:1px solid #333; padding-bottom:15px; margin-bottom:15px;">
                <div style="color:#fa0; font-size:12px; margin-bottom:5px;">장비 강화</div>
                <div id="smith-slot" class="slot" style="margin:0 auto 10px auto; width:50px; height:50px;" onclick="game.smith.clear('up')">선택</div>
                <button style="width:100%; padding:8px;" onclick="game.smith.upgrade()">강화 시도 (1000G)</button>
            </div>
            <div>
                <div style="color:#0ff; font-size:12px; margin-bottom:5px;">특성 각인</div>
                <div style="display:flex; justify-content:center; gap:15px; margin-bottom:10px;">
                    <div id="smith-en-item" class="slot" style="width:50px; height:50px;" onclick="game.smith.clear('enItem')">장비</div>
                    <div id="smith-en-stone" class="slot" style="width:50px; height:50px; border-radius:50%; border-color:#a0a;" onclick="game.smith.clear('enStone')">각인석</div>
                </div>
                <button style="width:100%; padding:8px;" onclick="game.smith.engrave()">각인 부여 (500G)</button>
            </div>
        </div>
    </div>

    <!-- Job Select -->
    <div id="job-select" class="ui-win modal" style="display:block; text-align:center; top:40%;">
        <div class="ui-head">CLASS SELECTION</div>
        <div style="padding:15px; display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
            <button style="padding:15px;" onclick="game.setJob(0)"><b style="color:#faa">전사</b><br><span style="font-size:10px; color:#666">근접/밸런스</span></button>
            <button style="padding:15px;" onclick="game.setJob(1)"><b style="color:#afa">궁수</b><br><span style="font-size:10px; color:#666">원거리/속도</span></button>
            <button style="padding:15px;" onclick="game.setJob(2)"><b style="color:#aaf">마법사</b><br><span style="font-size:10px; color:#666">광역/폭딜</span></button>
            <button style="padding:15px;" onclick="game.setJob(3)"><b style="color:#d8f">암살자</b><br><span style="font-size:10px; color:#666">치명/이속</span></button>
            <button style="padding:15px; grid-column: span 2;" onclick="game.setJob(4)"><b style="color:#fd8">성기사</b><br><span style="font-size:10px; color:#666">방어/회복</span></button>
        </div>
    </div>

    <div id="chat"></div>
</div>

<script>
/**
 * Config & Constants
 */
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');
let SCREEN_W = window.innerWidth;
let SCREEN_H = window.innerHeight;
const WORLD_W = 12000;
const WORLD_H = 12000;

// Zones (V13 Expanded & Fixed)
const ZONES = [
    { name: "평화의 숲", color: "#1a2b1a", x: 0, y: 0, w: 4000, h: 4000, lv: 1 },
    { name: "황무지", color: "#3d3018", x: 4000, y: 0, w: 4000, h: 4000, lv: 2 },
    { name: "설원", color: "#15202b", x: 0, y: 4000, w: 4000, h: 4000, lv: 3 },
    { name: "지옥", color: "#220505", x: 3000, y: 4000, w: 3000, h: 4000, lv: 4 },
    { name: "맹독의 늪", color: "#1a2205", x: 8000, y: 0, w: 4000, h: 4000, lv: 5 },
    { name: "천공의 섬", color: "#445566", x: 8000, y: 4000, w: 4000, h: 4000, lv: 6 },
    { name: "저주받은 묘지", color: "#111115", x: 0, y: 8000, w: 6000, h: 4000, lv: 7 },
    { name: "수정 동굴", color: "#201030", x: 6000, y: 8000, w: 6000, h: 4000, lv: 8 }
];

const TOWNS = [
    { name: "메인 마을", x: 2000, y: 2000, r: 400 },
    { name: "사막 캠프", x: 6000, y: 2000, r: 300 },
    { name: "설원 요새", x: 2000, y: 6000, r: 300 },
    { name: "지옥 전초기지", x: 6000, y: 6000, r: 300 },
    { name: "늪지 오두막", x: 10000, y: 2000, r: 300 },
    { name: "천공 신전", x: 10000, y: 6000, r: 300 },
    { name: "묘지기 초소", x: 3000, y: 10000, r: 300 },
    { name: "수정 광산", x: 9000, y: 10000, r: 300 }
];

const BOSS_SPOTS = [
    { name: "숲의 수호자", x: 3500, y: 3500, lv: 1, type: 2 },
    { name: "샌드 웜", x: 7500, y: 3500, lv: 2, type: 2 },
    { name: "예티 킹", x: 500, y: 7500, lv: 3, type: 2 },
    { name: "발록", x: 4500, y: 7500, lv: 4, type: 2 },
    { name: "히드라", x: 11500, y: 500, lv: 5, type: 2 },
    { name: "스카이 드래곤", x: 11500, y: 7500, lv: 6, type: 2 },
    { name: "리치 킹", x: 500, y: 11500, lv: 7, type: 2 },
    { name: "크리스탈 가디언", x: 11500, y: 11500, lv: 8, type: 2 }
];

const RARITY = [
    { n: '일반', c: '#888', cl: 'r-0', m: 1.0 },
    { n: '고급', c: '#4f4', cl: 'r-1', m: 1.5 },
    { n: '희귀', c: '#4af', cl: 'r-2', m: 2.5 },
    { n: '영웅', c: '#d4f', cl: 'r-3', m: 4.0 },
    { n: '전설', c: '#fa0', cl: 'r-4', m: 8.0 }, 
    { n: '신화', c: '#f22', cl: 'r-5', m: 15.0 },
    { n: '태고', c: '#0ff', cl: 'r-6', m: 30.0 }
];

const ENGRAVES = [
    { id: 'vamp', n: '흡혈' }, { id: 'crit', n: '치명' }, { id: 'exe', n: '처형' },
    { id: 'blast', n: '폭발' }, { id: 'stun', n: '기절' }, { id: 'spd', n: '신속' },
    { id: 'greed', n: '탐욕' }, { id: 'dodge', n: '회피' }, { id: 'leech', n: '마나흡수' }
];

const JOBS = [
    { n: '전사', hp: 1.2, mp: 0.8, range: 60, spd: 3.0, skills: ['강타','휠윈드','함성'] },
    { n: '궁수', hp: 0.8, mp: 1.0, range: 250, spd: 2.2, skills: ['더블샷','화살비','후퇴'] },
    { n: '마법사', hp: 0.7, mp: 1.5, range: 200, spd: 2.2, skills: ['화염구','눈보라','이동'] },
    { n: '암살자', hp: 0.9, mp: 1.0, range: 60, spd: 4.2, skills: ['기습','맹독','질주'] },
    { n: '성기사', hp: 1.4, mp: 1.2, range: 60, spd: 3.0, skills: ['심판','방패','축복'] }
];

/**
 * Utils
 */
function rand(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function getDist(e1, e2) { return Math.hypot(e1.x - e2.x, e1.y - e2.y); }
function clamp(v, min, max) { return Math.min(Math.max(v, min), max); }
function log(msg, type='c-sys') {
    const p = document.getElementById('chat');
    p.innerHTML += `<div class="msg ${type}">${msg}</div>`;
    p.scrollTop = p.scrollHeight;
}
function spawnFloat(txt, x, y, col) {
    game.particles.push({
        type: 'text', txt: txt, x: x, y: y, col: col, life: 60,
        update: function(dt) { this.y -= 30 * dt; this.life -= 60 * dt; },
        draw: function(ctx, cam) {
            ctx.fillStyle = this.col; ctx.font = "bold 12px sans-serif";
            ctx.fillText(this.txt, this.x - cam.x, this.y - cam.y);
        }
    });
}
function getZoneName(x, y) {
    for(let z of ZONES) {
        if(x >= z.x && x < z.x + z.w && y >= z.y && y < z.y + z.h) return z.name;
    }
    return "위험 지대";
}

/**
 * Classes
 */
class Item {
    constructor(lv, type) {
        this.id = Math.random().toString(36).substr(2);
        this.type = type || (Math.random()<0.5 ? 'w' : 'a');
        if(type === 's') { this.name = "각인석"; this.rarity = 2; this.price = 200; return; }
        
        const r = Math.random();
        let ri = 0;
        if(r < 0.0001) ri = 6; else if(r < 0.0005) ri = 5; else if(r < 0.002) ri = 4;
        else if(r < 0.02) ri = 3; else if(r < 0.1) ri = 2; else if(r < 0.4) ri = 1;

        const info = RARITY[ri];
        this.rarity = ri;
        this.power = Math.floor((lv * 2 + 5) * info.m * rand(90,110)/100);
        this.up = 0;
        this.engrave = null;
        this.name = `${info.n} ${this.type==='w'?'검':'갑옷'}`;
        this.price = Math.floor(this.power * 5);

        if(ri >= 4) {
            const effects = ['번개', '화염', '빙결', '메테오', '체인'];
            this.effect = effects[rand(0,4)];
            this.name = `${this.effect}의 ${this.name}`;
        }
    }
}

class Entity {
    constructor(x, y, sz, col) {
        this.x = x; this.y = y; this.size = sz; this.col = col;
        this.hp = 100; this.maxHp = 100; this.dead = false;
        this.effects = [];
    }
    draw(ctx, cam) {
        if(this.x < cam.x-100 || this.x > cam.x+SCREEN_W+100 || this.y < cam.y-100 || this.y > cam.y+SCREEN_H+100) return;
        
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(this.x-cam.x, this.y+this.size/2-cam.y, this.size/1.5, this.size/3, 0, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = this.col;
        ctx.fillRect(this.x - this.size/2 - cam.x, this.y - this.size/2 - cam.y, this.size, this.size);

        const rx = this.x - 15 - cam.x; const ry = this.y - this.size - 8 - cam.y;
        ctx.fillStyle = '#000'; ctx.fillRect(rx, ry, 30, 4);
        ctx.fillStyle = (this.hp/this.maxHp)>0.5 ? '#0f0' : '#f00';
        ctx.fillRect(rx, ry, 30 * (this.hp/this.maxHp), 4);
    }
    updateEffects(dt) {
        if(this.dead) return;
        this.effects = this.effects.filter(e => e.time > 0);
        this.effects.forEach(e => {
            e.time -= dt * 60;
            e.tick -= dt * 60;
            if(e.type === 'poison' && e.tick <= 0) { this.takeDamage(e.val, true); spawnFloat("독", this.x, this.y-30, '#0f0'); e.tick = 60; }
            if(e.type === 'burn' && e.tick <= 0) { this.takeDamage(e.val, true); spawnFloat("화상", this.x, this.y-30, '#f50'); e.tick = 30; }
        });
    }
    addEffect(type, time, val) { this.effects.push({type, time, val, tick:0}); }
}

class Player extends Entity {
    constructor() {
        super(2000, 2000, 20, '#fff');
        this.level = 1; this.exp = 0; this.maxExp = 100;
        this.gold = 0; this.inv = []; this.eq = { w:null, a:null };
        this.stats = { str:5, dex:5, con:5, pt:0 };
        this.job = 0;
        this.mp = 100; this.maxMp = 100;
        this.potions = 5;
        this.target = null; this.dest = null;
        this.lastAtk = 0;
        this.skills = { q:0, w:0, e:0 }; 
        this.spd = 4;
        this.atkAnim = 0;
        this.regenTimer = 0;
    }

    update(dt) {
        if(this.dead) return;
        this.updateEffects(dt);
        
        this.regenTimer += dt;
        if(this.regenTimer >= 1.0) { 
            this.hp = Math.min(this.maxHp, this.hp + this.stats.con*0.2);
            this.mp = Math.min(this.maxMp, this.mp + 2);
            this.regenTimer = 0;
        }
        
        for(let k in this.skills) if(this.skills[k]>0) this.skills[k] -= dt * 60;

        if(this.target) {
            if(this.target.dead) {
                this.target = null;
            } else {
                const range = JOBS[this.job].range;
                const dist = getDist(this, this.target);
                
                if(this.dest) {
                    this.moveTo(this.dest.x, this.dest.y, dt);
                    if(getDist(this, this.dest) < 5) this.dest = null;
                } 
                else if(dist > range) {
                    this.moveTo(this.target.x, this.target.y, dt);
                }

                if(dist <= range) {
                    if(Date.now() - this.lastAtk > Math.max(200, 1000 - this.stats.dex*10)) {
                        this.attack(this.target);
                    }
                }
            }
        } else if(this.dest) {
            if(getDist(this, this.dest) < 5) this.dest = null;
            else this.moveTo(this.dest.x, this.dest.y, dt);
        }

        if(this.atkAnim > 0) this.atkAnim -= dt * 60;
    }

    moveTo(tx, ty, dt) {
        if(this.effects.some(e => e.type === 'freeze')) return;
        const rad = Math.atan2(ty - this.y, tx - this.x);
        const moveStep = this.spd * 60 * dt;
        this.x += Math.cos(rad) * moveStep;
        this.y += Math.sin(rad) * moveStep;
        this.x = clamp(this.x, 0, WORLD_W); this.y = clamp(this.y, 0, WORLD_H);
    }

    attack(t, multi=1.0, isSkill=false) {
        this.lastAtk = Date.now();
        this.atkAnim = 15;

        let dmg = (this.stats.str * 2 + (this.eq.w ? this.eq.w.power + this.eq.w.up*5 : 0)) * multi;
        let isCrit = false;
        
        const engrave = this.eq.w ? this.eq.w.engrave : null;
        if(engrave) {
            if(engrave.id === 'crit' && Math.random() < 0.2) { dmg *= 2; isCrit = true; }
            if(engrave.id === 'exe' && (t.hp/t.maxHp)<0.3) dmg *= 1.5;
            if(engrave.id === 'vamp') {
                const heal = Math.ceil(dmg * 0.1);
                this.hp = Math.min(this.maxHp, this.hp + heal);
                spawnFloat(`+${heal}`, this.x, this.y-30, '#0f0');
            }
            if(engrave.id === 'greed') game.player.gold += rand(1,5);
            if(engrave.id === 'leech') this.mp = Math.min(this.maxMp, this.mp + 2);
        }

        if(this.job === 3 && Math.random() < 0.4) { dmg *= 2.0; isCrit = true; } 

        dmg = Math.floor(dmg * (0.9 + Math.random()*0.2));
        t.takeDamage(dmg);

        const ang = Math.atan2(t.y - this.y, t.x - this.x);
        
        if(!isSkill) {
            if(this.job === 0 || this.job === 3 || this.job === 4) {
                const sx = this.x + Math.cos(ang) * 30;
                const sy = this.y + Math.sin(ang) * 30;
                game.particles.push({
                    type: 'slash', x: sx, y: sy, ang: ang, life: 12,
                    col: this.eq.w && this.eq.w.rarity >= 4 ? '#0ff' : '#fff'
                });
            } else {
                game.particles.push({
                    type: 'proj', x: this.x, y: this.y, tx: t.x, ty: t.y, life: 20,
                    col: this.job===1 ? '#ff0' : '#0af'
                });
            }
        }

        spawnFloat(dmg, t.x, t.y-20, isCrit?'#ff0':'#fff');
        
        if(this.eq.w && this.eq.w.effect) {
            if(Math.random() < 0.25) {
                const eff = this.eq.w.effect;
                if(eff === '번개') { spawnFloat("⚡", t.x, t.y-40, '#ff0'); t.takeDamage(dmg * 0.5); }
                else if(eff === '화염') t.addEffect('burn', 180, this.level);
                else if(eff === '빙결') t.addEffect('freeze', 60, 0);
                else if(eff === '메테오') {
                    game.particles.push({type:'aoe_warn', x:t.x, y:t.y, size:80, life:30});
                    setTimeout(()=>{
                        game.particles.push({type:'explosion', x:t.x, y:t.y, size:80, life:30, col:'#f50'});
                        t.takeDamage(dmg * 2.0);
                    }, 500);
                }
                else if(eff === '체인') {
                    game.monsters.forEach(m => {
                        if(m !== t && getDist(t, m) < 200) {
                            m.takeDamage(dmg * 0.5);
                            game.particles.push({type:'chain', x:t.x, y:t.y, tx:m.x, ty:m.y, life:10, col:'#ff0'});
                        }
                    });
                }
            }
        }
    }

    useSkill(key) {
        if(this.skills[key] > 0) return;
        if(this.mp < 20) { log("MP가 부족합니다."); return; }
        this.mp -= 20;
        this.skills[key] = 300; 
        
        const t = this.target;
        const x = this.x, y = this.y;

        if(this.job === 0) { // Warrior
            if(key==='q' && t) { this.attack(t, 2.5, true); game.particles.push({type:'shock', x:t.x, y:t.y, col:'#f00', life:20}); }
            else if(key==='w') { game.monsters.forEach(m => { if(getDist(this, m) < 120) this.attack(m, 0.8, true); }); game.particles.push({type:'spin', x:x, y:y, col:'#fa0', life:20}); }
            else if(key==='e') { this.hp = Math.min(this.maxHp, this.hp + this.maxHp*0.3); spawnFloat("HEAL", x, y-30, '#0f0'); game.particles.push({type:'aura', x:x, y:y, col:'#0f0', life:30}); }
        } 
        else if(this.job === 1) { // Archer
            if(key==='q' && t) { this.attack(t, 0.8, true); setTimeout(()=>this.attack(t, 0.8, true), 200); }
            else if(key==='w' && t) { for(let i=0; i<5; i++) setTimeout(() => { game.particles.push({type:'proj', x:t.x+rand(-50,50), y:t.y-100, tx:t.x, ty:t.y, life:10, col:'#ff0'}); this.attack(t, 0.4, true); }, i*100); }
            else if(key==='e') { const ang = t ? Math.atan2(this.y-t.y, this.x-t.x) : 0; this.x += Math.cos(ang)*150; this.y += Math.sin(ang)*150; }
        }
        else if(this.job === 2) { // Mage
            if(key==='q' && t) { game.particles.push({type:'proj', x:x, y:y, tx:t.x, ty:t.y, life:30, col:'#f50', size:10}); setTimeout(() => { this.attack(t, 3.0, true); game.particles.push({type:'explosion', x:t.x, y:t.y, col:'#f50', life:30}); }, 300); }
            else if(key==='w') { game.monsters.forEach(m => { if(getDist(this, m) < 200) { this.attack(m, 0.5, true); m.addEffect('freeze', 120, 0); } }); game.particles.push({type:'aura', x:x, y:y, col:'#0ff', life:40}); }
            else if(key==='e') { const ang = Math.random() * Math.PI * 2; this.x += Math.cos(ang)*200; this.y += Math.sin(ang)*200; game.particles.push({type:'shock', x:this.x, y:this.y, col:'#00f', life:20}); }
        }
        else if(this.job === 3) { // Assassin
            if(key==='q' && t) { this.x = t.x - 20; this.y = t.y; this.attack(t, 3.0, true); game.particles.push({type:'slash', x:t.x, y:t.y, ang:0, life:10, col:'#505'}); }
            else if(key==='w' && t) { t.addEffect('poison', 300, this.level*2); spawnFloat("POISON", t.x, t.y-30, '#0f0'); }
            else if(key==='e') { this.spd += 2; setTimeout(()=>this.spd-=2, 3000); spawnFloat("SPEED UP", x, y-30, '#fff'); }
        }
        else if(this.job === 4) { // Paladin
            if(key==='q' && t) { this.attack(t, 1.5, true); t.addEffect('stun', 60, 0); game.particles.push({type:'shock', x:t.x, y:t.y, col:'#ff0', life:20}); }
            else if(key==='w') { this.addEffect('shield', 300, 0); spawnFloat("SHIELD", x, y-30, '#ff0'); }
            else if(key==='e') { this.hp = Math.min(this.maxHp, this.hp + this.maxHp*0.2); game.monsters.forEach(m=>{if(getDist(this,m)<150) this.attack(m,1.0,true)}); game.particles.push({type:'aura', x:x, y:y, col:'#ff0', life:30}); }
        }
    }

    // V13: Fixed Damage Formula (Min 20% guaranteed)
    takeDamage(d, ignoreDef=false) {
        if(this.effects.some(e=>e.type==='shield')) d *= 0.5;
        if(this.eq.w && this.eq.w.engrave && this.eq.w.engrave.id === 'dodge' && Math.random() < 0.2) {
            spawnFloat("MISS", this.x, this.y-30, '#888');
            return;
        }

        const def = ignoreDef ? 0 : (this.stats.con*0.5 + (this.eq.a ? this.eq.a.power + this.eq.a.up*5 : 0));
        
        // V13: Logic Change - Minimum damage is 20% of incoming damage, or raw difference, whichever is higher
        // This prevents high defense from making you invincible (1 dmg) and fixes healing bug
        const minDmg = d * 0.2; 
        const calcDmg = d - def;
        const real = Math.max(minDmg, calcDmg);
        
        // Final sanity check to ensure at least 1 damage if d > 0
        const finalDmg = Math.max(1, Math.floor(real));

        this.hp -= finalDmg;
        spawnFloat(finalDmg, this.x, this.y-20, '#f00');
        
        if(this.hp <= 0) {
            log("사망했습니다.", "c-dmg");
            this.x=2000; this.y=2000; this.hp=this.maxHp; this.mp=this.maxMp;
            this.dead = false; this.effects = [];
            game.save();
        }
    }
}

class Monster extends Entity {
    constructor(zone, isBossInfo) {
        let type = 0; 
        if(isBossInfo) type = 2;
        else if(Math.random() < 0.05) type = 1;

        let x, y;
        if(type===2) { x=isBossInfo.x; y=isBossInfo.y; }
        else { x=rand(zone.x, zone.x+zone.w); y=rand(zone.y, zone.y+zone.h); }

        let scale = zone.lv;
        
        const cols = ['#4f4', '#da4', '#adf', '#f55', '#4d4', '#88f', '#666', '#a4a'];
        let col = cols[zone.lv-1];
        if(type===1) col = '#fb0';
        if(type===2) col = '#f00';

        super(x, y, 20 + scale*4, col);
        this.type = type;
        
        if(type === 2) {
            this.name = `[BOSS] ${isBossInfo.name}`;
            this.level = isBossInfo.lv * 10;
            this.maxHp = 500 * scale * scale; 
            this.atk = 5 * scale * 25; // V13: Boss Atk Buffed to pierce Def
            this.size = 60;
        } else {
            this.name = type===1 ? `[Elite] ${zone.name} 수호자` : '몬스터';
            this.level = scale * 5;
            this.maxHp = 50 * scale * scale;
            this.atk = 5 * scale * 4; // V13: Normal Atk Buffed
            
            if(type === 1) { 
                this.maxHp *= 3;
                this.atk *= 1; 
                this.size = 40;
            }
        }
        
        this.hp = this.maxHp;
        this.exp = 10 * scale * (type+1);
        this.gold = rand(5, 15) * scale * (type+1);
        this.spd = 1.5 + (Math.random()*0.5);
        this.patTimer = 0;
        this.bossInfo = isBossInfo;
        this.anim = 0; // Attack Cooldown
    }

    update(p, dt) {
        if(this.dead) return;
        this.updateEffects(dt);
        if(this.effects.some(e => e.type === 'freeze' || e.type === 'stun')) return;

        const dist = getDist(this, p);
        
        if(this.type === 2 && dist < 800) {
            game.activeBoss = this;
            this.bossBehavior(p, dist, dt);
            return;
        }

        if(dist < 400) {
            // V13: Improved Attack Logic
            // If close enough
            if(dist <= this.size + 30) {
                // If cooldown ready
                if(this.anim <= 0) {
                    this.anim = 1.0; // Reset Cooldown (1 sec)
                    
                    // Visual Telegraph
                    if(this.type > 0) game.particles.push({type:'charge', x:this.x, y:this.y, col:this.col, life:30});
                    
                    // Deal Damage (Instant for normal, delayed for elite/boss feel)
                    // Simplified: All instant but checked again
                    if(!this.dead && getDist(this, p) <= this.size + 30) {
                        p.takeDamage(this.atk);
                        if(this.type>0) game.particles.push({type:'shock', x:p.x, y:p.y, col:'#f00', life:15});
                    }
                }
            } else {
                // Chase
                const ang = Math.atan2(p.y - this.y, p.x - this.x);
                const move = this.spd * 60 * dt;
                this.x += Math.cos(ang) * move;
                this.y += Math.sin(ang) * move;
            }
        }
        
        // Cooldown tick
        if(this.anim > 0) this.anim -= dt;
    }

    bossBehavior(p, dist, dt) {
        this.patTimer += dt;
        if(this.patTimer > 3.0) { 
            this.patTimer = 0;
            const action = rand(0, 2);
            if(action === 0) { // AoE
                game.particles.push({type:'aoe_warn', x:p.x, y:p.y, life:60, size:100});
                setTimeout(() => {
                    if(getDist(p, {x:p.x, y:p.y}) < 100) p.takeDamage(this.atk * 1.5);
                    game.particles.push({type:'explosion', x:p.x, y:p.y, col:'#f00', life:30, size:100});
                }, 1000);
            } else if(action === 1) { // Barrage
                for(let i=0; i<5; i++) {
                    setTimeout(() => {
                        game.particles.push({type:'proj', x:this.x, y:this.y, tx:p.x+rand(-50,50), ty:p.y+rand(-50,50), life:40, col:'#f00', size:8, enemy:true, atk:this.atk});
                    }, i*100);
                }
            } else { // Dash
                const ang = Math.atan2(p.y - this.y, p.x - this.x);
                this.x += Math.cos(ang) * 300; this.y += Math.sin(ang) * 300;
                game.particles.push({type:'slash', x:this.x, y:this.y, ang:ang, life:20, col:'#fff'});
                if(getDist(this, p) < 80) p.takeDamage(this.atk);
            }
        }
        if(dist > 50) {
            const ang = Math.atan2(p.y - this.y, p.x - this.x);
            const move = this.spd * 0.5 * 60 * dt;
            this.x += Math.cos(ang) * move;
            this.y += Math.sin(ang) * move;
        }
    }

    takeDamage(d, ignoreDef=false) {
        this.hp -= d;
        if(this.hp <= 0) {
            this.dead = true;
            game.player.exp += this.exp;
            game.player.gold += this.gold;
            if(game.player.exp >= game.player.maxExp) {
                game.player.level++; game.player.exp=0; game.player.maxExp*=1.2;
                game.player.stats.pt += 3; game.player.maxHp+=20; game.player.hp=game.player.maxHp;
                spawnFloat("LEVEL UP", this.x, this.y-40, '#ff0');
                game.ui.updatePanel();
            }
            if(this.type===2) {
                game.activeBoss = null;
                document.getElementById('boss-ui').style.display = 'none';
                game.bossRespawn[this.bossInfo.name] = Date.now() + 60000;
            }
            this.drop();
        }
    }

    drop() {
        if(Math.random() < 0.3) {
            const item = new Item(this.level);
            game.player.inv.push(item);
            log(`${item.name} 획득`, item.rarity>=3?'c-rare':'c-get');
            game.ui.updatePanel();
        }
        if(this.type > 0 && Math.random() < 0.5) {
            game.player.inv.push(new Item(1, 's'));
            log("각인석 획득", 'c-rare');
            game.ui.updatePanel();
        }
    }
}

class Game {
    constructor() {
        this.player = new Player();
        this.monsters = [];
        this.particles = [];
        this.cam = { x:0, y:0 };
        this.frame = 0;
        this.activeBoss = null;
        this.bossRespawn = {}; 
        
        this.ui = new UI(this);
        this.smith = new Smith(this);
        
        this.lastTime = 0;
        this.init();
    }

    init() {
        CANVAS.addEventListener('mousedown', e => {
            const r = CANVAS.getBoundingClientRect();
            const wx = e.clientX - r.left + this.cam.x;
            const wy = e.clientY - r.top + this.cam.y;
            
            let t = null;
            for(let i=this.monsters.length-1; i>=0; i--) {
                const m = this.monsters[i];
                if(!m.dead && getDist({x:wx, y:wy}, m) < m.size+15) { t = m; break; }
            }

            if(t) {
                this.player.target = t;
                this.player.dest = null;
                game.particles.push({type:'shock', x:t.x, y:t.y, col:'#f00', life:10, size:30});
            } else {
                this.player.dest = {x:wx, y:wy};
                game.particles.push({type:'shock', x:wx, y:wy, col:'#0f0', life:10, size:10});
            }
        });
        
        CANVAS.addEventListener('dblclick', e => { this.player.target = null; });

        window.addEventListener('keydown', e => {
            if(['q','w','e'].includes(e.key.toLowerCase())) this.player.useSkill(e.key.toLowerCase());
            if(e.key.toLowerCase() === 'p') {
                if(this.player.potions > 0) {
                    this.player.potions--;
                    this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.maxHp*0.5);
                    spawnFloat("HP UP", this.player.x, this.player.y-30, '#0f0');
                }
            }
            if(e.key === 'Escape') this.player.target = null;
        });

        window.addEventListener('resize', () => {
            SCREEN_W = window.innerWidth; SCREEN_H = window.innerHeight;
            CANVAS.width = SCREEN_W; CANVAS.height = SCREEN_H;
        });
        CANVAS.width = SCREEN_W; CANVAS.height = SCREEN_H;

        if(localStorage.getItem('rpg_v12') || localStorage.getItem('rpg_v11')) {
            this.load();
            document.getElementById('job-select').style.display = 'none';
        }
        
        this.ui.updatePanel();
        this.ui.updateIcons();

        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    setJob(id) {
        this.player.job = id;
        this.player.maxHp *= JOBS[id].hp; this.player.hp = this.player.maxHp;
        this.player.maxMp *= JOBS[id].mp; this.player.mp = this.player.maxMp;
        this.player.spd = JOBS[id].spd;
        document.getElementById('job-select').style.display = 'none';
        this.ui.updatePanel();
        this.ui.updateIcons();
        log(`${JOBS[id].n}로 모험을 시작합니다.`);
    }

    loop(timestamp) {
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = (timestamp - this.lastTime) / 1000; 
        this.lastTime = timestamp;
        const safeDt = Math.min(dt, 0.1);

        this.frame++;
        
        this.monsters = this.monsters.filter(m => !m.dead);
        if(this.monsters.filter(m=>m.type!==2).length < 200) { 
            const z = ZONES[rand(0, ZONES.length-1)];
            const mx = rand(z.x, z.x+z.w);
            const my = rand(z.y, z.y+z.h);
            let safe = false;
            for(let t of TOWNS) { if(getDist({x:mx, y:my}, t) < t.r + 100) safe = true; }
            if(!safe) {
                const m = new Monster(z); m.x = mx; m.y = my;
                this.monsters.push(m);
            }
        }

        BOSS_SPOTS.forEach(b => {
            const exists = this.monsters.some(m => m.type === 2 && m.bossInfo.name === b.name);
            if(!exists) {
                const respawnTime = this.bossRespawn[b.name] || 0;
                if(Date.now() > respawnTime) {
                    const boss = new Monster(ZONES[b.lv-1], b);
                    this.monsters.push(boss);
                }
            }
        });

        this.player.update(safeDt);
        this.monsters.forEach(m => m.update(this.player, safeDt));

        const bossUi = document.getElementById('boss-ui');
        if(this.activeBoss && !this.activeBoss.dead) {
            bossUi.style.display = 'block';
            document.getElementById('boss-name').innerText = this.activeBoss.name;
            document.getElementById('boss-fill').style.width = (this.activeBoss.hp / this.activeBoss.maxHp * 100) + '%';
        } else {
            bossUi.style.display = 'none';
        }

        this.cam.x = clamp(this.player.x - SCREEN_W/2, 0, WORLD_W - SCREEN_W);
        this.cam.y = clamp(this.player.y - SCREEN_H/2, 0, WORLD_H - SCREEN_H);

        const ctx = CTX;
        ctx.fillStyle = '#050505'; ctx.fillRect(0,0,SCREEN_W,SCREEN_H);

        ZONES.forEach(z => {
            if(z.x+z.w > this.cam.x && z.x < this.cam.x+SCREEN_W && z.y+z.h > this.cam.y && z.y < this.cam.y+SCREEN_H) {
                ctx.fillStyle = z.color; ctx.fillRect(z.x - this.cam.x, z.y - this.cam.y, z.w, z.h);
            }
        });
        
        TOWNS.forEach(t => {
             if(t.x+t.r > this.cam.x && t.x-t.r < this.cam.x+SCREEN_W) {
                 ctx.fillStyle = 'rgba(0,0,0,0.5)';
                 ctx.beginPath(); ctx.arc(t.x-this.cam.x, t.y-this.cam.y, t.r, 0, Math.PI*2); ctx.fill();
                 ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.font = "16px serif";
                 ctx.fillText(t.name, t.x-this.cam.x, t.y-this.cam.y);
             }
        });

        this.monsters.forEach(m => m.draw(ctx, this.cam));
        this.player.draw(ctx, this.cam);

        if(this.player.atkAnim > 0) {
            ctx.save();
            ctx.translate(this.player.x - this.cam.x, this.player.y - this.cam.y);
            let ang = 0;
            if(this.player.target) ang = Math.atan2(this.player.target.y - this.player.y, this.player.target.x - this.player.x);
            else if(this.player.dest) ang = Math.atan2(this.player.dest.y - this.player.y, this.player.dest.x - this.player.x);
            
            ctx.rotate(ang + (this.player.atkAnim/15)); 
            
            ctx.fillStyle = this.player.eq.w ? RARITY[this.player.eq.w.rarity].c : '#ccc';
            ctx.shadowBlur = this.player.eq.w && this.player.eq.w.rarity >= 4 ? 10 : 0;
            ctx.shadowColor = ctx.fillStyle;
            ctx.fillRect(10, -2, 30, 4); 
            ctx.restore();
        }

        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => {
            p.update && p.update(safeDt);
            if(p.type === 'text') p.draw(ctx, this.cam);
            else if(p.type === 'slash') {
                ctx.save(); 
                ctx.translate(p.x-this.cam.x, p.y-this.cam.y); 
                ctx.rotate(p.ang);
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = p.col;
                ctx.beginPath();
                ctx.arc(0, 0, 50, -0.8, 0.8);
                ctx.arc(10, 0, 40, 0.8, -0.8, true);
                ctx.fill();
                ctx.restore(); 
                p.life -= 60 * safeDt;
            }
            else if(p.type === 'proj') {
                p.x += (p.tx - p.x) * 2.0 * safeDt; 
                p.y += (p.ty - p.y) * 2.0 * safeDt;
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = p.col; ctx.beginPath(); ctx.arc(p.x-this.cam.x, p.y-this.cam.y, p.size||6, 0, Math.PI*2); ctx.fill();
                ctx.globalAlpha = 0.5;
                ctx.beginPath(); ctx.arc(p.x-this.cam.x - (p.tx-p.x)*0.1, p.y-this.cam.y - (p.ty-p.y)*0.1, p.size||4, 0, Math.PI*2); ctx.fill();
                ctx.restore();
                if(p.enemy && getDist(p, this.player) < 20) { this.player.takeDamage(p.atk); p.life=0; }
                p.life -= 60 * safeDt;
            }
            else if(p.type === 'explosion') {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = p.col; ctx.globalAlpha = p.life/30;
                ctx.beginPath(); ctx.arc(p.x-this.cam.x, p.y-this.cam.y, p.size||50, 0, Math.PI*2); ctx.fill();
                ctx.restore();
                p.life -= 60 * safeDt;
            }
            else if(p.type === 'aoe_warn') {
                 ctx.strokeStyle = '#f00'; ctx.lineWidth = 2; ctx.globalAlpha = 0.5;
                 ctx.beginPath(); ctx.arc(p.x-this.cam.x, p.y-this.cam.y, p.size, 0, Math.PI*2); ctx.stroke();
                 ctx.fillStyle = 'rgba(255,0,0,0.2)'; ctx.fill(); ctx.globalAlpha = 1.0;
                 p.life -= 60 * safeDt;
            }
            else if(p.type === 'chain') {
                ctx.save(); ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = p.col; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(p.x-this.cam.x, p.y-this.cam.y);
                const midX = (p.x + p.tx)/2 + rand(-20,20);
                const midY = (p.y + p.ty)/2 + rand(-20,20);
                ctx.lineTo(midX-this.cam.x, midY-this.cam.y);
                ctx.lineTo(p.tx-this.cam.x, p.ty-this.cam.y);
                ctx.stroke(); ctx.restore(); p.life -= 60 * safeDt;
            }
            else if(p.type === 'shock' || p.type === 'spin' || p.type === 'aura' || p.type === 'charge') {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = p.col; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(p.x-this.cam.x, p.y-this.cam.y, (40-p.life)*2, 0, Math.PI*2); ctx.stroke(); 
                ctx.restore();
                p.life -= 60 * safeDt;
            }
        });

        if(this.player.target && !this.player.target.dead) {
            const t = this.player.target;
            ctx.strokeStyle = '#f00'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(t.x-this.cam.x, t.y-this.cam.y, t.size+10, 0, Math.PI*2); ctx.stroke();
        }

        if(this.frame % 3600 === 0) this.save();

        this.ui.updateHUD();

        requestAnimationFrame(this.loop);
    }

    save(manual = false) {
        const p = this.player;
        const saveData = {
            level: p.level, exp: p.exp, maxExp: p.maxExp,
            gold: p.gold, hp: p.hp, maxHp: p.maxHp, mp: p.mp, maxMp: p.maxMp,
            stats: p.stats, job: p.job, potions: p.potions,
            inv: p.inv, eq: p.eq, x: p.x, y: p.y
        };
        localStorage.setItem('rpg_v13', JSON.stringify(saveData));
        if(manual) alert("저장되었습니다.");
    }

    reset() {
        if(confirm("정말 초기화하시겠습니까?")) {
            localStorage.removeItem('rpg_v13');
            location.reload();
        }
    }

    load() {
        try {
            let json = localStorage.getItem('rpg_v13') || localStorage.getItem('rpg_v12');
            if(json) {
                const d = JSON.parse(json);
                const p = this.player;
                
                p.level = d.level; p.exp = d.exp; p.maxExp = d.maxExp;
                p.gold = d.gold; p.hp = d.hp; p.maxHp = d.maxHp; p.mp = d.mp; p.maxMp = d.maxMp;
                p.stats = d.stats; p.job = d.job; p.potions = d.potions;
                p.x = d.x; p.y = d.y;
                p.spd = JOBS[p.job].spd;

                const restoreItem = (i) => {
                    const n = new Item(1);
                    Object.assign(n, i);
                    return n;
                };

                p.inv = d.inv.map(restoreItem);
                if(d.eq.w) p.eq.w = restoreItem(d.eq.w);
                if(d.eq.a) p.eq.a = restoreItem(d.eq.a);

                this.ui.updatePanel();
                this.ui.updateIcons();
                log("데이터 로드 완료.");
            }
        } catch(e) { console.error("Load Failed", e); }
    }
}

class UI {
    constructor(g) { this.g = g; this.panelOpen = true; }

    updateHUD() {
        const p = this.g.player;
        document.getElementById('u-lv').innerText = p.level;
        document.getElementById('u-gold').innerText = p.gold.toLocaleString();
        document.getElementById('u-pot').innerText = p.potions;
        document.getElementById('u-zone').innerText = getZoneName(p.x, p.y);
        
        document.getElementById('hp-bar').style.width = (p.hp/p.maxHp*100)+'%';
        document.getElementById('mp-bar').style.width = (p.mp/p.maxMp*100)+'%';
        document.getElementById('exp-bar').style.width = (p.exp/p.maxExp*100)+'%';

        ['q','w','e'].forEach(k => {
            const el = document.getElementById(`cd-${k}`);
            if(p.skills[k] > 0) {
                el.style.display = 'flex';
                el.innerText = Math.ceil(p.skills[k]/60);
            } else el.style.display = 'none';
        });
    }

    updateIcons() {
        const j = JOBS[this.g.player.job];
        document.querySelector('#slot-q .key-hint').innerText = "Q " + j.skills[0];
        document.querySelector('#slot-w .key-hint').innerText = "W " + j.skills[1];
        document.querySelector('#slot-e .key-hint').innerText = "E " + j.skills[2];
    }

    updatePanel() {
        if(!this.panelOpen) return;
        const p = this.g.player;
        document.getElementById('u-job').innerText = JOBS[p.job].n;
        document.getElementById('st-atk').innerText = Math.floor(p.stats.str*2 + (p.eq.w?p.eq.w.power+p.eq.w.up*5:0));
        document.getElementById('st-def').innerText = Math.floor(p.stats.con*0.5 + (p.eq.a?p.eq.a.power+p.eq.a.up*5:0));
        document.getElementById('st-pt').innerText = p.stats.pt;
        document.getElementById('inv-cnt').innerText = p.inv.length;

        const setEq = (id, it, type) => {
            const el = document.getElementById(id);
            el.innerHTML = it ? `<span style="color:${RARITY[it.rarity].c}">${it.name}</span>` : (type==='w'?'WPN':'AMR');
            el.className = it ? `slot ${RARITY[it.rarity].cl}` : 'slot';
            el.onclick = () => { if(it) { p.inv.push(it); if(type==='w') p.eq.w=null; else p.eq.a=null; this.updatePanel(); } };
        };
        setEq('eq-w', p.eq.w, 'w'); setEq('eq-a', p.eq.a, 'a');

        const grid = document.getElementById('inv-grid');
        grid.innerHTML = '';
        p.inv.forEach((it, i) => {
            const d = document.createElement('div');
            d.className = `slot ${RARITY[it.rarity].cl}`;
            d.innerHTML = it.type==='s' ? 'GEM' : (it.type==='w'?'W':'A');
            if(it.up > 0) d.innerHTML += `+${it.up}`;
            if(it.engrave) d.innerHTML += ` <span style='color:#0ff'>★</span>`;
            
            d.onclick = () => {
                if(document.getElementById('smith-modal').style.display==='block') {
                    if(it.type === 's') game.smith.selStone(it, i);
                    else game.smith.sel(it, i);
                } else if(it.type !== 's') {
                    if(it.type==='w') { if(p.eq.w) p.inv.push(p.eq.w); p.eq.w=it; }
                    else { if(p.eq.a) p.inv.push(p.eq.a); p.eq.a=it; }
                    p.inv.splice(i, 1);
                    this.updatePanel();
                }
            };
            d.oncontextmenu = (e) => { e.preventDefault(); if(document.getElementById('shop-modal').style.display==='block') { p.gold+=it.price; p.inv.splice(i,1); this.updatePanel(); } };
            grid.appendChild(d);
        });
    }

    togglePanel() {
        this.panelOpen = !this.panelOpen;
        const content = document.getElementById('panel-content');
        if(this.panelOpen) {
            content.style.opacity = '1';
            content.style.pointerEvents = 'auto';
            setTimeout(() => content.style.display = 'block', 0);
            this.updatePanel();
        } else {
            content.style.opacity = '0';
            content.style.pointerEvents = 'none';
            setTimeout(() => content.style.display = 'none', 200);
        }
    }

    toggleShop() {
        this.closeModals();
        const p = this.g.player;
        if(!TOWNS.some(t => getDist(p, t) < t.r)) { log("마을이 아닙니다."); return; }
        document.getElementById('shop-modal').style.display='block';
        const l = document.getElementById('shop-list'); l.innerHTML='';
        const items = [
            {n:'체력 물약 (10G)', p:10, f:()=>{p.potions++;}},
            {n:'랜덤 장비 (500G)', p:500, f:()=>{p.inv.push(new Item(p.level));}},
            {n:'고급 장비 (2000G)', p:2000, f:()=>{p.inv.push(new Item(p.level));}}
        ];
        items.forEach(i => {
            const b = document.createElement('button');
            b.innerText = i.n; b.style.width='100%'; b.style.marginBottom='5px';
            b.onclick = () => { if(p.gold>=i.p) { p.gold-=i.p; i.f(); this.updatePanel(); } else log("골드 부족"); };
            l.appendChild(b);
        });
        this.updatePanel();
    }
    toggleSmith() {
        this.closeModals();
        if(!TOWNS.some(t => getDist(this.g.player, t) < t.r)) { log("마을이 아닙니다."); return; }
        document.getElementById('smith-modal').style.display='block';
    }
    closeModals() { document.querySelectorAll('.modal').forEach(e=>e.style.display='none'); }
}

class Smith {
    constructor(g) { this.g = g; this.item = null; this.iIdx = -1; this.stone = null; this.sIdx = -1; }
    
    sel(it, i) {
        this.item = it; this.iIdx = i;
        const el1 = document.getElementById('smith-slot'); el1.className = `slot ${RARITY[it.rarity].cl}`; el1.innerHTML = "SEL";
        const el2 = document.getElementById('smith-en-item'); el2.className = `slot ${RARITY[it.rarity].cl}`; el2.innerHTML = "SEL";
    }
    
    selStone(it, i) {
        this.stone = it; this.sIdx = i;
        const el = document.getElementById('smith-en-stone'); el.className = `slot ${RARITY[it.rarity].cl}`; el.innerHTML = "GEM";
    }

    clear(t) {
        if(t==='up' || t==='enItem') { 
            this.item=null; 
            document.getElementById('smith-slot').className='slot'; document.getElementById('smith-slot').innerHTML='선택';
            document.getElementById('smith-en-item').className='slot'; document.getElementById('smith-en-item').innerHTML='장비';
        }
        if(t==='enStone') {
            this.stone=null;
            document.getElementById('smith-en-stone').className='slot'; document.getElementById('smith-en-stone').innerHTML='각인석';
        }
    }

    upgrade() {
        if(!this.item) return;
        const p = this.g.player;
        if(p.gold < 1000) { log("골드 부족"); return; }
        p.gold -= 1000;
        if(Math.random() < 0.7) {
            this.item.up++; this.item.power += 5; log("강화 성공!", "c-get");
        } else log("강화 실패...", "c-dmg");
        this.g.ui.updatePanel();
        this.sel(this.item, this.iIdx);
    }

    engrave() {
        if(!this.item || !this.stone) { log("장비와 각인석이 필요합니다."); return; }
        const p = this.g.player;
        if(p.gold < 500) { log("골드 부족"); return; }
        p.gold -= 500;
        p.inv.splice(this.sIdx, 1);
        const eff = ENGRAVES[rand(0, ENGRAVES.length-1)];
        this.item.engrave = eff;
        log(`각인 성공: [${eff.n}]`, "c-rare");
        spawnFloat("ENGRAVE!", p.x, p.y-50, '#0ff');
        this.stone = null; this.sIdx = -1;
        document.getElementById('smith-en-stone').className='slot'; document.getElementById('smith-en-stone').innerHTML='각인석';
        this.g.ui.updatePanel();
    }
}

const game = new Game();
</script>
</body>
</html>
